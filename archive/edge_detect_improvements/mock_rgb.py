#this file was generated by claude - FAST version with minimal CPU overhead

import cv2
import numpy as np
import time
import sys

class Rgb_Handler:
    def __init__(self, port_index=1, fps_cap=60):
        """
        Fast mock RGB handler - generates simple frames quickly
        """
        self.USE_FILE = True  # Change to True to use video file
        self.VIDEO_FILE = "test_rgb.mp4"  # Path to your test video
        
        if self.USE_FILE:
            self.cap = cv2.VideoCapture(self.VIDEO_FILE)
            if not self.cap.isOpened():
                print(f"Cannot open video file: {self.VIDEO_FILE}")
                print("Falling back to synthetic frames")
                self.USE_FILE = False
            else:
                # Get video properties
                orig_width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
                orig_height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
                print(f"Video loaded: {orig_width}x{orig_height}")
                
                # Set target resolution for performance
                self.target_width = 640  # Adjust this for performance
                aspect_ratio = orig_height / orig_width
                self.target_height = int(self.target_width * aspect_ratio)
                print(f"Will resize to: {self.target_width}x{self.target_height} for performance")
        
        if not self.USE_FILE:
            # Generate synthetic video properties
            self.frame_width = 640
            self.frame_height = 480
            self.fps = fps_cap
            self.frame_delay = 1.0 / self.fps
        else:
            self.fps = fps_cap
            
        self.framecount = 0
        self.prevMillis = 0
        self.last_frame_time = time.time()
        print(f"Fast Mock RGB Handler initialized at {fps_cap} FPS")
    
    def print_fps(self):
        millis = int(round(time.time() * 1000))
        self.framecount += 1
        if millis - self.prevMillis > 1000:
            print(f"RGB FPS: {self.framecount}")
            self.prevMillis = millis 
            self.framecount = 0
    
    def get_frame(self):
        """Generate or read a frame"""
        if self.USE_FILE:
            ret, frame = self.cap.read()
            if not ret:
                # Loop video
                self.cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
                ret, frame = self.cap.read()
            if not ret:
                print("Can't receive frame from video file")
                sys.exit(1)
        else:
            # Generate synthetic frame FAST
            frame = self._generate_fast_frame()
            
            # No frame timing delay - run as fast as possible
        
        return frame
    
    def _generate_fast_frame(self):
        """Generate a fast synthetic RGB frame using numpy operations"""
        t = time.time()
        
        # Create a simple gradient background (FAST - no loops)
        y_grad = np.linspace(50, 200, self.frame_height, dtype=np.uint8)
        x_grad = np.linspace(50, 200, self.frame_width, dtype=np.uint8)
        
        # Create RGB channels
        frame = np.zeros((self.frame_height, self.frame_width, 3), dtype=np.uint8)
        frame[:, :, 0] = x_grad  # Blue
        frame[:, :, 1] = y_grad[:, np.newaxis]  # Green
        frame[:, :, 2] = 128  # Red constant
        
        # Add some moving shapes for interest
        num_shapes = 3
        for i in range(num_shapes):
            x = int((np.sin(t * 0.5 + i * 2) + 1) * self.frame_width / 2)
            y = int((np.cos(t * 0.3 + i * 2) + 1) * self.frame_height / 2)
            radius = 30 + i * 15
            color = (255, 255, 255)
            cv2.circle(frame, (x, y), radius, color, 2)
        
        # Add some rectangles for edge detection to pick up (more visible)
        # Commented out - remove if you don't want rectangles
        # cv2.rectangle(frame, (50, 50), (150, 150), (255, 255, 255), 3)
        # cv2.rectangle(frame, (self.frame_width - 150, 50), 
        #              (self.frame_width - 50, 150), (255, 255, 255), 3)
        
        return frame
    
    def release(self):
        if self.USE_FILE and hasattr(self, 'cap'):
            self.cap.release()