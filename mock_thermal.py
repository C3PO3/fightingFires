#this file was generated by claude to mock thermal video for performance testing without hardware available

import cv2
import numpy as np
import time
import sys

class Thermal_Handler:
    def __init__(self, device_index, fps_cap=60):
        """
        Mock Thermal handler that generates synthetic thermal video
        """
        self.USE_FILE = False  # Set to True to read from file
        self.VIDEO_FILE = "test_thermal.mp4"
        
        if self.USE_FILE:
            self.cap = cv2.VideoCapture(self.VIDEO_FILE)
            if not self.cap.isOpened():
                print(f"Cannot open thermal video file: {self.VIDEO_FILE}")
                print("Falling back to synthetic thermal frames")
                self.USE_FILE = False
        
        if not self.USE_FILE:
            # Generate synthetic video properties
            self.frame_width = 640
            self.frame_height = 512
            self.fps = fps_cap
            self.frame_delay = 1.0 / self.fps
        else:
            self.fps = fps_cap
            
        self.framecount = 0
        self.prevMillis = 0
        self.last_frame_time = time.time()
        print(f"Mock Thermal Handler initialized at {fps_cap} FPS")
    
    def print_fps(self):
        millis = int(round(time.time() * 1000))
        self.framecount += 1
        if millis - self.prevMillis > 1000:
            print(f"Thermal FPS: {self.framecount}")
            self.prevMillis = millis 
            self.framecount = 0
    
    def get_frame(self):
        """Generate or read a thermal frame (grayscale)"""
        if self.USE_FILE:
            ret, frame = self.cap.read()
            if not ret:
                # Loop video
                self.cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
                ret, frame = self.cap.read()
            if not ret:
                print("Can't receive frame from thermal video file")
                sys.exit(1)
            # Convert to grayscale if needed
            if len(frame.shape) == 3:
                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        else:
            # Generate synthetic thermal frame
            frame = self._generate_synthetic_thermal()
            
            # Simulate frame timing
            elapsed = time.time() - self.last_frame_time
            if elapsed < self.frame_delay:
                time.sleep(self.frame_delay - elapsed)
            self.last_frame_time = time.time()
        
        return frame
    
    def _generate_synthetic_thermal(self):
        """Generate synthetic thermal imagery (grayscale with hot spots)"""
        # Base temperature map
        frame = np.ones((self.frame_height, self.frame_width), dtype=np.uint8) * 80
        
        # Add thermal gradient (cooler at edges)
        y, x = np.ogrid[:self.frame_height, :self.frame_width]
        center_y, center_x = self.frame_height // 2, self.frame_width // 2
        
        # Distance from center
        dist = np.sqrt((x - center_x)**2 + (y - center_y)**2)
        max_dist = np.sqrt(center_x**2 + center_y**2)
        
        # Apply gradient
        gradient = (1 - dist / max_dist) * 100
        frame = frame + gradient.astype(np.uint8)
        
        # Add moving "hot spots"
        t = time.time()
        num_hotspots = 3
        for i in range(num_hotspots):
            x_pos = int((np.sin(t * 0.5 + i * 2) + 1) * self.frame_width / 2)
            y_pos = int((np.cos(t * 0.3 + i * 2) + 1) * self.frame_height / 2)
            
            # Create hot spot with Gaussian blur
            hotspot = np.zeros_like(frame)
            cv2.circle(hotspot, (x_pos, y_pos), 40, 255, -1)
            hotspot = cv2.GaussianBlur(hotspot, (51, 51), 0)
            
            # Add to frame
            frame = cv2.add(frame, hotspot // 3)
        
        # Add some noise to simulate thermal noise
        noise = np.random.randint(-10, 10, (self.frame_height, self.frame_width), dtype=np.int16)
        frame = np.clip(frame.astype(np.int16) + noise, 0, 255).astype(np.uint8)
        
        return frame
    
    def release(self):
        if self.USE_FILE and hasattr(self, 'cap'):
            self.cap.release()