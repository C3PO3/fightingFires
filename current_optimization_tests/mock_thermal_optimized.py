#this file was generated by claude - OPTIMIZED version with minimal CPU overhead

import cv2
import numpy as np
import time
import sys

class Thermal_Handler:
    def __init__(self, device_index, fps_cap=60):
        """
        Optimized Thermal handler that generates synthetic thermal video
        """
        self.USE_FILE = False  # Set to True to read from file
        self.VIDEO_FILE = "test_thermal.mp4"
        
        if self.USE_FILE:
            self.cap = cv2.VideoCapture(self.VIDEO_FILE)
            if not self.cap.isOpened():
                print(f"Cannot open thermal video file: {self.VIDEO_FILE}")
                print("Falling back to synthetic thermal frames")
                self.USE_FILE = False
        
        if not self.USE_FILE:
            # Generate synthetic video properties
            self.frame_width = 640
            self.frame_height = 512
            self.fps = fps_cap
            
            # Pre-compute thermal gradient (static part)
            y, x = np.ogrid[:self.frame_height, :self.frame_width]
            center_y, center_x = self.frame_height // 2, self.frame_width // 2
            dist = np.sqrt((x - center_x)**2 + (y - center_y)**2)
            max_dist = np.sqrt(center_x**2 + center_y**2)
            self.static_gradient = ((1 - dist / max_dist) * 100).astype(np.uint8)
            
            # Pre-allocate frame buffer
            self.frame_buffer = np.empty((self.frame_height, self.frame_width), dtype=np.uint8)
            
            # Pre-compute hotspot mask
            self.hotspot_radius = 40
            self.hotspot_mask = np.zeros((self.frame_height, self.frame_width), dtype=np.uint8)
            
        else:
            self.fps = fps_cap
            
        self.framecount = 0
        self.prevMillis = 0
        self.last_frame_time = time.time()
        print(f"Optimized Mock Thermal Handler initialized at {fps_cap} FPS")
    
    def print_fps(self):
        millis = int(round(time.time() * 1000))
        self.framecount += 1
        if millis - self.prevMillis > 1000:
            print(f"Thermal FPS: {self.framecount}")
            self.prevMillis = millis 
            self.framecount = 0
    
    def get_frame(self):
        """Generate or read a thermal frame (grayscale)"""
        if self.USE_FILE:
            ret, frame = self.cap.read()
            if not ret:
                # Loop video
                self.cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
                ret, frame = self.cap.read()
            if not ret:
                print("Can't receive frame from thermal video file")
                sys.exit(1)
            # Convert to grayscale if needed
            if len(frame.shape) == 3:
                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        else:
            # Generate synthetic thermal frame
            frame = self._generate_synthetic_thermal_fast()
        
        return frame
    
    def _generate_synthetic_thermal_fast(self):
        """Optimized synthetic thermal imagery generation"""
        # Start with base temperature + static gradient
        self.frame_buffer[:] = 80
        self.frame_buffer = cv2.add(self.frame_buffer, self.static_gradient)
        
        # Add moving "hot spots" (simplified - only 2 hotspots for speed)
        t = time.time()
        for i in range(2):  # Reduced from 3 to 2
            x_pos = int((np.sin(t * 0.5 + i * 2) + 1) * self.frame_width / 2)
            y_pos = int((np.cos(t * 0.3 + i * 2) + 1) * self.frame_height / 2)
            
            # Fast circular hotspot (no Gaussian blur for speed)
            cv2.circle(self.frame_buffer, (x_pos, y_pos), self.hotspot_radius, 255, -1)
        
        # Add minimal noise (reduced intensity for speed)
        noise = np.random.randint(-5, 5, (self.frame_height, self.frame_width), dtype=np.int16)
        self.frame_buffer = np.clip(self.frame_buffer.astype(np.int16) + noise, 0, 255).astype(np.uint8)
        
        return self.frame_buffer
    
    def release(self):
        if self.USE_FILE and hasattr(self, 'cap'):
            self.cap.release()