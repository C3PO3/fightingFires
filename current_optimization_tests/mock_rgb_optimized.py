#this file was generated by claude - OPTIMIZED version with minimal CPU overhead

import cv2
import numpy as np
import time
import sys

class Rgb_Handler:
    def __init__(self, port_index=1, fps_cap=60):
        """
        Optimized mock RGB handler - generates simple frames quickly
        """
        self.USE_FILE = True  # Change to True to use video file
        self.VIDEO_FILE = "test_rgb.mp4"  # Path to your test video
        
        if self.USE_FILE:
            self.cap = cv2.VideoCapture(self.VIDEO_FILE)
            if not self.cap.isOpened():
                print(f"Cannot open video file: {self.VIDEO_FILE}")
                print("Falling back to synthetic frames")
                self.USE_FILE = False
            else:
                # Get video properties
                orig_width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
                orig_height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
                print(f"Video loaded: {orig_width}x{orig_height}")
                
                # Set target resolution for performance
                self.target_width = 640  # Adjust this for performance
                aspect_ratio = orig_height / orig_width
                self.target_height = int(self.target_width * aspect_ratio)
                print(f"Will resize to: {self.target_width}x{self.target_height} for performance")
                
                # Pre-allocate resize buffer
                self.resize_buffer = np.empty((self.target_height, self.target_width, 3), dtype=np.uint8)
        
        if not self.USE_FILE:
            # Generate synthetic video properties
            self.frame_width = 640
            self.frame_height = 480
            self.fps = fps_cap
            
            # Pre-generate gradient arrays for synthetic frames
            self.y_grad = np.linspace(50, 200, self.frame_height, dtype=np.uint8)
            self.x_grad = np.linspace(50, 200, self.frame_width, dtype=np.uint8)
            self.base_frame = np.zeros((self.frame_height, self.frame_width, 3), dtype=np.uint8)
        else:
            self.fps = fps_cap
            
        self.framecount = 0
        self.prevMillis = 0
        self.last_frame_time = time.time()
        print(f"Optimized Mock RGB Handler initialized at {fps_cap} FPS")
    
    def print_fps(self):
        millis = int(round(time.time() * 1000))
        self.framecount += 1
        if millis - self.prevMillis > 1000:
            print(f"RGB FPS: {self.framecount}")
            self.prevMillis = millis 
            self.framecount = 0
    
    def get_frame(self):
        """Generate or read a frame"""
        if self.USE_FILE:
            ret, frame = self.cap.read()
            if not ret:
                # Loop video
                self.cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
                ret, frame = self.cap.read()
            if not ret:
                print("Can't receive frame from video file")
                sys.exit(1)
            
            # Fast resize using pre-allocated buffer
            cv2.resize(frame, (self.target_width, self.target_height), 
                      dst=self.resize_buffer, interpolation=cv2.INTER_LINEAR)
            return self.resize_buffer
        else:
            # Generate synthetic frame FAST
            return self._generate_fast_frame()
    
    def _generate_fast_frame(self):
        """Generate a fast synthetic RGB frame using numpy operations"""
        t = time.time()
        
        # Reuse base frame
        frame = self.base_frame.copy()
        frame[:, :, 0] = self.x_grad  # Blue
        frame[:, :, 1] = self.y_grad[:, np.newaxis]  # Green
        frame[:, :, 2] = 128  # Red constant
        
        # Add some moving shapes for interest (simplified)
        num_shapes = 3
        for i in range(num_shapes):
            x = int((np.sin(t * 0.5 + i * 2) + 1) * self.frame_width / 2)
            y = int((np.cos(t * 0.3 + i * 2) + 1) * self.frame_height / 2)
            radius = 30 + i * 15
            cv2.circle(frame, (x, y), radius, (255, 255, 255), 2)
        
        return frame
    
    def release(self):
        if self.USE_FILE and hasattr(self, 'cap'):
            self.cap.release()